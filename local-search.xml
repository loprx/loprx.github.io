<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于Jdk1.8中Stream的一些API的解释</title>
    <link href="/2023/07/08/java/jdk8.stream/"/>
    <url>/2023/07/08/java/jdk8.stream/</url>
    
    <content type="html"><![CDATA[<h2 id="如何创建一个Steam流"><a href="#如何创建一个Steam流" class="headerlink" title="如何创建一个Steam流"></a>如何创建一个Steam流</h2><p>实现了<code>Collection</code>接口的类，都可以使用stream流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Iterable</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns a possibly parallel &#123;<span class="hljs-doctag">@code</span> Stream&#125; with this collection as its</span><br><span class="hljs-comment">     * source.  It is allowable for this method to return a sequential stream.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;This method should be overridden when the &#123;<span class="hljs-doctag">@link</span> #spliterator()&#125;</span><br><span class="hljs-comment">     * method cannot return a spliterator that is &#123;<span class="hljs-doctag">@code</span> IMMUTABLE&#125;,</span><br><span class="hljs-comment">     * &#123;<span class="hljs-doctag">@code</span> CONCURRENT&#125;, or &lt;em&gt;late-binding&lt;/em&gt;. (See &#123;<span class="hljs-doctag">@link</span> #spliterator()&#125;</span><br><span class="hljs-comment">     * for details.)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@implSpec</span></span><br><span class="hljs-comment">     * The default implementation creates a parallel &#123;<span class="hljs-doctag">@code</span> Stream&#125; from the</span><br><span class="hljs-comment">     * collection&#x27;s &#123;<span class="hljs-doctag">@code</span> Spliterator&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> a possibly parallel &#123;<span class="hljs-doctag">@code</span> Stream&#125; over the elements in this</span><br><span class="hljs-comment">     * collection</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@since</span> 1.8</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> Stream&lt;E&gt; <span class="hljs-title function_">parallelStream</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StreamSupport.stream(spliterator(), <span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以采用工具类Arrays将字符串、数组转换为List，从而使用<code>Collection</code>中的stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br>List&lt;Integer&gt; evenNumbers = numbers.stream()<br>                                   .filter(n -&gt; n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)<br>                                   .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p><code>Stream.of</code>：可以使用该方法创建一个包含指定元素的流。</p><p><code>Arrays.stream</code>：可以使用该方法将数组转换为流。</p><p><code>IntStream.range</code>和<code>IntStream.rangeClosed</code>：可以使用这两个方法创建指定范围的整数流。</p><p><code>Stream.generate</code>和<code>Stream.iterate</code>：可以使用这两个方法创建无限流。</p><h2 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h2><ol><li>归约（Reduce）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers.stream()<br>                 .reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p>这个示例使用reduce操作将集合中的元素求和。</p><ol start="2"><li>扁平化（FlatMap）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; numberLists = Arrays.asList(<br>    Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>),<br>    Arrays.asList(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>),<br>    Arrays.asList(<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>)<br>);<br>List&lt;Integer&gt; flattenedList = numberLists.stream()<br>                                         .flatMap(Collection::stream)<br>                                         .collect(Collectors.toList());<br></code></pre></td></tr></table></figure><p>flatMap操作用于将嵌套的集合扁平化为一个单一的集合。</p><ol start="3"><li>并行处理</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; numbers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers.parallelStream()<br>                 .reduce(<span class="hljs-number">0</span>, Integer::sum);<br></code></pre></td></tr></table></figure><p>通过使用parallelStream方法，我们可以将Stream的处理并行化，从而提高处理大量数据的效率。<br>也可以使用<code>stream().parallel()</code>。</p><p>使用<code>sequential()</code>可切换为串行流</p><ol start="4"><li>分组（groupingBy）</li></ol><p>将流中的元素按照指定的条件进行分组，返回一个Map，其中键是分组的条件，值是对应的元素列表。</p><ol start="5"><li>分区（partitioningBy）</li></ol><p>将流中的元素按照指定的条件进行分区，返回一个Map，其中键是分区的条件（true或false），值是对应的元素列表。</p><ol start="6"><li>提前终止操作</li></ol><p>findFirst：返回流中的第一个元素。</p><p>findAny：返回流中的任意一个元素。</p><p>anyMatch：判断流中是否存在满足指定条件的元素。</p><p>allMatch：判断流中的所有元素是否都满足指定条件。</p><p>noneMatch：判断流中是否没有任何元素满足指定条件。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
